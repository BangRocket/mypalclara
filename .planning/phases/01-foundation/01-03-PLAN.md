---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - webui/src-tauri/Cargo.toml
  - webui/src-tauri/src/lib.rs
  - webui/src-tauri/src/commands/mod.rs
  - webui/src-tauri/src/commands/notes.rs
  - webui/src-tauri/src/models/mod.rs
  - webui/src-tauri/src/models/note.rs
  - webui/src/lib/bindings.ts
  - webui/src/App.tsx
  - webui/package.json
autonomous: true

must_haves:
  truths:
    - "TypeScript types are auto-generated from Rust structs"
    - "React can call Rust commands with full type safety"
    - "A basic note CRUD command works end-to-end"
    - "Changes to Rust types regenerate TypeScript bindings"
  artifacts:
    - path: "webui/src-tauri/src/commands/notes.rs"
      provides: "Note CRUD commands"
      exports: ["list_notes", "create_note"]
    - path: "webui/src/lib/bindings.ts"
      provides: "Auto-generated TypeScript bindings"
      contains: "export async function"
    - path: "webui/src-tauri/src/models/note.rs"
      provides: "Note model with specta derive"
      contains: "specta::Type"
  key_links:
    - from: "webui/src/App.tsx"
      to: "webui/src/lib/bindings.ts"
      via: "import and function call"
      pattern: "import.*from.*bindings"
    - from: "webui/src/lib/bindings.ts"
      to: "webui/src-tauri/src/commands/notes.rs"
      via: "tauri invoke"
      pattern: "invoke.*list_notes"
---

# Plan 03: Type-Safe IPC with tauri-specta

## Objective

Establish type-safe IPC between React and Rust using tauri-specta. Create a basic notes CRUD skeleton that demonstrates the pattern for all future commands.

## Context

Phase 1 acceptance criteria requires "at least one Rust command callable from React with type safety." This plan establishes the IPC pattern that all features will follow.

**Key research findings to apply:**
- Use tauri-specta v2 for TypeScript binding generation
- Use specta v2 with derive feature for type exports
- Generate bindings in debug builds, commit for CI
- Commands use `State<'_, Database>` to access managed state
- Return `Result<T, String>` for consistent error handling

**Pitfalls to avoid:**
- Manual TypeScript types drift from Rust (Pitfall 4) - solved by codegen
- IPC serialization bottleneck (Pitfall 1) - return only what's needed

## Tasks

<task id="03.01">
<title>Add tauri-specta dependencies</title>
<instruction>
Update `webui/src-tauri/Cargo.toml` to add specta dependencies:

```toml
[dependencies]
tauri = { version = "2", features = [] }
tauri-plugin-opener = "2"
serde = { version = "1", features = ["derive"] }
serde_json = "1"

# Database
sqlx = { version = "0.8", features = ["runtime-tokio", "sqlite"] }
tokio = { version = "1", features = ["full"] }

# Type-safe IPC
tauri-specta = { version = "2", features = ["derive", "typescript"] }
specta = { version = "2", features = ["derive"] }
specta-typescript = "0.0.7"

[build-dependencies]
tauri-build = { version = "2", features = [] }
```

Run cargo check:

```bash
cd /Users/heidornj/Code/mypalclara/webui/src-tauri
cargo check
```

Note: specta-typescript generates the TypeScript bindings file.
</instruction>
<files>
- webui/src-tauri/Cargo.toml
</files>
</task>

<task id="03.02">
<title>Create models module with specta types</title>
<instruction>
Create the models directory structure.

Create `webui/src-tauri/src/models/mod.rs`:

```rust
pub mod note;

pub use note::*;
```

Create `webui/src-tauri/src/models/note.rs`:

```rust
use serde::{Deserialize, Serialize};
use specta::Type;

/// A note in the knowledge base
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
pub struct Note {
    pub id: i64,
    pub title: String,
    pub content: String,
    pub folder_id: Option<i64>,
    pub author: String,
    pub created_at: String,
    pub updated_at: String,
}

/// Input for creating a new note
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
pub struct CreateNoteInput {
    pub title: String,
    pub content: Option<String>,
    pub folder_id: Option<i64>,
}

/// Input for updating a note
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
pub struct UpdateNoteInput {
    pub title: Option<String>,
    pub content: Option<String>,
    pub folder_id: Option<i64>,
}

/// A folder for organizing notes
#[derive(Debug, Clone, Serialize, Deserialize, Type)]
pub struct Folder {
    pub id: i64,
    pub name: String,
    pub parent_id: Option<i64>,
    pub created_at: String,
    pub updated_at: String,
}
```

Key points:
- All types derive `specta::Type` for TypeScript generation
- Use `Option<T>` for nullable fields
- Use `String` for timestamps (SQLite stores as TEXT)
- Separate input types for create/update operations
</instruction>
<files>
- webui/src-tauri/src/models/mod.rs
- webui/src-tauri/src/models/note.rs
</files>
</task>

<task id="03.03">
<title>Create commands module with note CRUD skeleton</title>
<instruction>
Create the commands directory structure.

Create `webui/src-tauri/src/commands/mod.rs`:

```rust
pub mod notes;

pub use notes::*;
```

Create `webui/src-tauri/src/commands/notes.rs`:

```rust
use crate::db::Database;
use crate::models::{CreateNoteInput, Note, UpdateNoteInput};
use tauri::State;

/// List all notes, optionally filtered by folder
#[tauri::command]
#[specta::specta]
pub async fn list_notes(
    db: State<'_, Database>,
    folder_id: Option<i64>,
) -> Result<Vec<Note>, String> {
    let notes = match folder_id {
        Some(fid) => {
            sqlx::query_as!(
                Note,
                r#"
                SELECT id, title, content, folder_id, author, created_at, updated_at
                FROM notes
                WHERE folder_id = ?
                ORDER BY updated_at DESC
                "#,
                fid
            )
            .fetch_all(&db.pool)
            .await
        }
        None => {
            sqlx::query_as!(
                Note,
                r#"
                SELECT id, title, content, folder_id, author, created_at, updated_at
                FROM notes
                ORDER BY updated_at DESC
                "#
            )
            .fetch_all(&db.pool)
            .await
        }
    };

    notes.map_err(|e| e.to_string())
}

/// Get a single note by ID
#[tauri::command]
#[specta::specta]
pub async fn get_note(db: State<'_, Database>, id: i64) -> Result<Note, String> {
    sqlx::query_as!(
        Note,
        r#"
        SELECT id, title, content, folder_id, author, created_at, updated_at
        FROM notes
        WHERE id = ?
        "#,
        id
    )
    .fetch_one(&db.pool)
    .await
    .map_err(|e| e.to_string())
}

/// Create a new note
#[tauri::command]
#[specta::specta]
pub async fn create_note(
    db: State<'_, Database>,
    input: CreateNoteInput,
) -> Result<Note, String> {
    let content = input.content.unwrap_or_default();

    let result = sqlx::query!(
        r#"
        INSERT INTO notes (title, content, folder_id, author)
        VALUES (?, ?, ?, 'user')
        "#,
        input.title,
        content,
        input.folder_id
    )
    .execute(&db.pool)
    .await
    .map_err(|e| e.to_string())?;

    let id = result.last_insert_rowid();

    get_note(db, id).await
}

/// Update an existing note
#[tauri::command]
#[specta::specta]
pub async fn update_note(
    db: State<'_, Database>,
    id: i64,
    input: UpdateNoteInput,
) -> Result<Note, String> {
    // Fetch current note to merge updates
    let current = get_note(db.clone(), id).await?;

    let title = input.title.unwrap_or(current.title);
    let content = input.content.unwrap_or(current.content);
    let folder_id = input.folder_id.or(current.folder_id);

    sqlx::query!(
        r#"
        UPDATE notes
        SET title = ?, content = ?, folder_id = ?, updated_at = datetime('now')
        WHERE id = ?
        "#,
        title,
        content,
        folder_id,
        id
    )
    .execute(&db.pool)
    .await
    .map_err(|e| e.to_string())?;

    get_note(db, id).await
}

/// Delete a note
#[tauri::command]
#[specta::specta]
pub async fn delete_note(db: State<'_, Database>, id: i64) -> Result<(), String> {
    sqlx::query!("DELETE FROM notes WHERE id = ?", id)
        .execute(&db.pool)
        .await
        .map_err(|e| e.to_string())?;

    Ok(())
}
```

Key patterns:
- All commands are async (required for database operations)
- All commands return `Result<T, String>` for error handling
- Use `#[specta::specta]` attribute for TypeScript generation
- Access database via `State<'_, Database>`
- Use `sqlx::query_as!` for type-safe queries
</instruction>
<files>
- webui/src-tauri/src/commands/mod.rs
- webui/src-tauri/src/commands/notes.rs
</files>
</task>

<task id="03.04">
<title>Update lib.rs with specta builder and command registration</title>
<instruction>
Update `webui/src-tauri/src/lib.rs` to register commands and generate bindings:

```rust
mod commands;
mod db;
mod models;

use commands::notes;
use db::Database;
use tauri::Manager;
use tauri_specta::{collect_commands, Builder};

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    // Build specta command registry
    let builder = Builder::<tauri::Wry>::new()
        .commands(collect_commands![
            notes::list_notes,
            notes::get_note,
            notes::create_note,
            notes::update_note,
            notes::delete_note,
        ]);

    // Generate TypeScript bindings in debug mode
    #[cfg(debug_assertions)]
    builder
        .export(
            specta_typescript::Typescript::default()
                .bigint(specta_typescript::BigIntExportBehavior::Number),
            "../src/lib/bindings.ts",
        )
        .expect("Failed to export TypeScript bindings");

    tauri::Builder::default()
        .plugin(tauri_plugin_opener::init())
        .invoke_handler(builder.invoke_handler())
        .setup(move |app| {
            // Register specta types for runtime
            builder.mount_events(app);

            // Initialize database
            let app_handle = app.handle().clone();
            tauri::async_runtime::block_on(async move {
                match Database::new(&app_handle).await {
                    Ok(db) => {
                        app_handle.manage(db);
                        println!("Database ready");
                    }
                    Err(e) => {
                        eprintln!("Failed to initialize database: {}", e);
                    }
                }
            });
            Ok(())
        })
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

Key changes:
- Import commands and models modules
- Create tauri-specta Builder with all commands
- Export TypeScript bindings to `../src/lib/bindings.ts` (in debug mode only)
- Use `builder.invoke_handler()` instead of `tauri::generate_handler![]`
- Use `builder.mount_events(app)` in setup
- BigIntExportBehavior::Number converts i64 to number (not BigInt)
</instruction>
<files>
- webui/src-tauri/src/lib.rs
</files>
</task>

<task id="03.05">
<title>Create lib directory and verify bindings generation</title>
<instruction>
Create the lib directory for generated bindings:

```bash
mkdir -p /Users/heidornj/Code/mypalclara/webui/src/lib
```

Run the app to generate TypeScript bindings:

```bash
cd /Users/heidornj/Code/mypalclara/webui
npm run tauri dev
```

After the app starts, verify bindings were generated:

```bash
cat /Users/heidornj/Code/mypalclara/webui/src/lib/bindings.ts
```

**Expected content (approximate):**
```typescript
// This file was generated by [tauri-specta]. Do not edit this file manually.

import { invoke as __invoke } from "@tauri-apps/api/core";

export type Note = {
    id: number;
    title: string;
    content: string;
    folder_id: number | null;
    author: string;
    created_at: string;
    updated_at: string;
};

export type CreateNoteInput = {
    title: string;
    content: string | null;
    folder_id: number | null;
};

// ... more types and functions
```

Close the app after verifying.

**If bindings not generated:**
1. Check console for specta export errors
2. Ensure `src/lib/` directory exists
3. Verify Cargo.toml has specta-typescript dependency
</instruction>
<files>
- webui/src/lib/bindings.ts
</files>
</task>

<task id="03.06">
<title>Update React app to demonstrate IPC</title>
<instruction>
Update `webui/src/App.tsx` to call the Rust commands:

```tsx
import { useEffect, useState } from "react";
import { listNotes, createNote, type Note } from "./lib/bindings";
import "./App.css";

function App() {
  const [notes, setNotes] = useState<Note[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Fetch notes on mount
  useEffect(() => {
    loadNotes();
  }, []);

  async function loadNotes() {
    try {
      setLoading(true);
      setError(null);
      const result = await listNotes(null);
      setNotes(result);
    } catch (e) {
      setError(e as string);
    } finally {
      setLoading(false);
    }
  }

  async function handleCreateNote() {
    try {
      const note = await createNote({
        title: `New Note ${notes.length + 1}`,
        content: "# Hello\n\nThis note was created from React!",
        folder_id: 1, // Default folder
      });
      setNotes([note, ...notes]);
    } catch (e) {
      setError(e as string);
    }
  }

  return (
    <main className="container">
      <h1>MyPalClara Desktop</h1>
      <p>Clara's collaborative knowledge workspace</p>

      <div className="card">
        <button onClick={handleCreateNote}>Create Note</button>
        <button onClick={loadNotes} style={{ marginLeft: "0.5rem" }}>
          Refresh
        </button>
      </div>

      {loading && <p>Loading notes...</p>}
      {error && <p className="error">Error: {error}</p>}

      <div className="notes-list">
        <h2>Notes ({notes.length})</h2>
        {notes.length === 0 && !loading && (
          <p>No notes yet. Click "Create Note" to add one.</p>
        )}
        {notes.map((note) => (
          <div key={note.id} className="note-item">
            <strong>{note.title}</strong>
            <span className="note-meta">
              {note.author} - {new Date(note.updated_at).toLocaleDateString()}
            </span>
          </div>
        ))}
      </div>

      <p className="read-the-docs">Phase 1: Foundation complete</p>
    </main>
  );
}

export default App;
```

Update `webui/src/App.css` to add styles:

```css
.container {
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
  padding: 2rem;
  text-align: center;
}

h1 {
  font-size: 2.5rem;
  margin-bottom: 0.5rem;
}

h2 {
  font-size: 1.5rem;
  margin: 1rem 0;
}

.card {
  padding: 1rem;
  margin: 1rem 0;
}

.card button {
  padding: 0.6rem 1.2rem;
  font-size: 1rem;
  cursor: pointer;
  border-radius: 8px;
  border: 1px solid transparent;
  background-color: #1a1a1a;
  color: white;
  transition: border-color 0.25s;
}

.card button:hover {
  border-color: #646cff;
}

.error {
  color: #ff6b6b;
  background: #2a1a1a;
  padding: 0.5rem 1rem;
  border-radius: 4px;
}

.notes-list {
  width: 100%;
  max-width: 500px;
  text-align: left;
  margin-top: 1rem;
}

.note-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.75rem;
  margin: 0.5rem 0;
  background: #1a1a1a;
  border-radius: 4px;
}

.note-meta {
  font-size: 0.8rem;
  color: #888;
}

.read-the-docs {
  color: #888;
  font-size: 0.9rem;
  margin-top: 2rem;
}
```

This demonstrates:
- Importing generated types and functions
- Calling async Rust commands from React
- Error handling for IPC calls
- React state management with IPC data
</instruction>
<files>
- webui/src/App.tsx
- webui/src/App.css
</files>
</task>

<task id="03.07">
<title>Verify end-to-end IPC works</title>
<instruction>
Run the app and test the complete flow:

```bash
cd /Users/heidornj/Code/mypalclara/webui
npm run tauri dev
```

**Test sequence:**
1. App launches showing "Notes (0)"
2. Click "Create Note" - a new note appears
3. Click "Create Note" again - second note appears
4. Click "Refresh" - notes persist (from database)
5. Close and reopen app - notes still there
6. Check database directly:

```bash
sqlite3 ~/Library/Application\ Support/com.mypalclara.desktop/notes.db "SELECT * FROM notes"
```

**Expected:**
- Notes are created with id, title, content, timestamps
- Author is 'user' (not 'clara')
- folder_id is 1 (default Notes folder)

**TypeScript verification:**
1. In VS Code, hover over `listNotes` - should show type signature
2. Try `createNote({ wrong: "field" })` - TypeScript should error
3. `note.title` autocompletes correctly

Close the app after verifying.

**If IPC fails:**
1. Check console for Rust panic messages
2. Verify database was initialized (check for db error in logs)
3. Check bindings.ts has the function exports
</instruction>
<files>
- webui/src-tauri/target/
</files>
</task>

## Verification

<verify>
- [ ] `webui/src/lib/bindings.ts` exists with generated types
- [ ] TypeScript types match Rust structs (Note, CreateNoteInput, etc.)
- [ ] `listNotes()` returns array of notes from database
- [ ] `createNote()` creates note and returns it
- [ ] Notes persist across app restarts
- [ ] TypeScript provides autocomplete for note properties
- [ ] TypeScript errors on invalid input shapes
</verify>

## Success Criteria

- Type-safe IPC established between React and Rust
- TypeScript bindings auto-generated from Rust types
- Basic CRUD operations work end-to-end
- Pattern established for all future commands
- Foundation complete for Phase 2 features

## Output

After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md` with:
- Generated bindings file size and type count
- IPC latency observations (if notable)
- Any TypeScript/Rust type mapping issues
- Time taken
