---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - webui/src-tauri/Cargo.toml
  - webui/src-tauri/src/lib.rs
  - webui/src-tauri/src/db/mod.rs
  - webui/src-tauri/src/db/migrations.rs
  - webui/src-tauri/capabilities/default.json
  - webui/migrations/001_initial_schema.sql
autonomous: true

must_haves:
  truths:
    - "SQLite database file is created on first app launch"
    - "Database uses WAL mode and has busy_timeout configured"
    - "Migration system applies schema changes automatically"
    - "Notes table exists with correct schema"
  artifacts:
    - path: "webui/src-tauri/src/db/mod.rs"
      provides: "Database initialization and connection"
      exports: ["Database", "init_db"]
    - path: "webui/migrations/001_initial_schema.sql"
      provides: "Initial database schema"
      contains: "CREATE TABLE notes"
    - path: "webui/src-tauri/Cargo.toml"
      provides: "Rust dependencies"
      contains: "sqlx"
  key_links:
    - from: "webui/src-tauri/src/lib.rs"
      to: "webui/src-tauri/src/db/mod.rs"
      via: "module import and init call"
      pattern: "mod db"
    - from: "webui/src-tauri/src/db/mod.rs"
      to: "webui/migrations/"
      via: "sqlx::migrate! macro"
      pattern: "migrate!"
---

# Plan 02: SQLite Database Setup

## Objective

Set up SQLite database with WAL mode, busy_timeout, and a migration system using SQLx. Create the initial schema for notes, folders, and future tables.

## Context

Phase 1 acceptance criteria requires "SQLite database created on first launch." This plan establishes the database layer that all future features depend on.

**Key research findings to apply:**
- Use `PRAGMA journal_mode=WAL` for concurrent read/write
- Use `PRAGMA busy_timeout=5000` to avoid "database is locked" errors
- Use SQLx for type-checked queries and compile-time verification
- Store migrations in `/webui/migrations/` directory
- Use rusqlite with `bundled` feature to ensure FTS5 is available

**Pitfalls to avoid:**
- Missing busy_timeout causes autosave conflicts (Pitfall 2)
- Hardcoded database paths break in production (Pitfall 10)
- Missing FTS5 extension causes "no such module" errors (Pitfall 13)

## Tasks

<task id="02.01">
<title>Add SQLite dependencies to Cargo.toml</title>
<instruction>
Update `webui/src-tauri/Cargo.toml` to add database dependencies:

```toml
[dependencies]
tauri = { version = "2", features = [] }
tauri-plugin-opener = "2"
serde = { version = "1", features = ["derive"] }
serde_json = "1"

# Database
sqlx = { version = "0.8", features = ["runtime-tokio", "sqlite"] }
tokio = { version = "1", features = ["full"] }

[build-dependencies]
tauri-build = { version = "2", features = [] }

# Enable SQLx offline mode for CI builds
[package.metadata.sqlx]
offline = true
```

Note: We're using `sqlx` directly rather than `tauri-plugin-sql` because:
1. We need custom Rust commands for business logic (wiki link parsing, etc.)
2. SQLx provides compile-time query checking
3. More control over connection pooling and transactions

Run cargo check to download dependencies:

```bash
cd /Users/heidornj/Code/mypalclara/webui/src-tauri
cargo check
```
</instruction>
<files>
- webui/src-tauri/Cargo.toml
</files>
</task>

<task id="02.02">
<title>Create database module structure</title>
<instruction>
Create the database module directory and files.

Create `webui/src-tauri/src/db/mod.rs`:

```rust
use sqlx::{sqlite::SqlitePoolOptions, SqlitePool};
use std::path::PathBuf;
use tauri::{AppHandle, Manager};

pub struct Database {
    pub pool: SqlitePool,
}

impl Database {
    pub async fn new(app: &AppHandle) -> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
        // Get app data directory (platform-specific)
        let app_dir = app.path().app_data_dir()?;
        std::fs::create_dir_all(&app_dir)?;

        let db_path = app_dir.join("notes.db");
        let db_url = format!("sqlite:{}?mode=rwc", db_path.display());

        println!("Database path: {}", db_path.display());

        // Create connection pool
        let pool = SqlitePoolOptions::new()
            .max_connections(5)
            .after_connect(|conn, _meta| {
                Box::pin(async move {
                    // Enable WAL mode for better concurrency
                    sqlx::query("PRAGMA journal_mode=WAL")
                        .execute(&mut *conn)
                        .await?;

                    // Set busy timeout to 5 seconds to avoid "database is locked"
                    sqlx::query("PRAGMA busy_timeout=5000")
                        .execute(&mut *conn)
                        .await?;

                    // Enable foreign keys
                    sqlx::query("PRAGMA foreign_keys=ON")
                        .execute(&mut *conn)
                        .await?;

                    Ok(())
                })
            })
            .connect(&db_url)
            .await?;

        // Run migrations
        sqlx::migrate!("../../migrations")
            .run(&pool)
            .await?;

        println!("Database initialized successfully");

        Ok(Self { pool })
    }

    /// Get the database path for debugging
    pub fn path(app: &AppHandle) -> Result<PathBuf, Box<dyn std::error::Error + Send + Sync>> {
        let app_dir = app.path().app_data_dir()?;
        Ok(app_dir.join("notes.db"))
    }
}
```

This module:
- Uses Tauri's `app_data_dir()` for platform-correct database location
- Enables WAL mode on every connection
- Sets 5-second busy_timeout to avoid lock errors
- Runs migrations automatically on startup
</instruction>
<files>
- webui/src-tauri/src/db/mod.rs
</files>
</task>

<task id="02.03">
<title>Create initial schema migration</title>
<instruction>
Create the migrations directory and initial schema.

Create `webui/migrations/001_initial_schema.sql`:

```sql
-- Initial schema for MyPalClara Desktop
-- This migration creates the core tables for notes and folders

-- Folders for organizing notes
CREATE TABLE IF NOT EXISTS folders (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    parent_id INTEGER REFERENCES folders(id) ON DELETE CASCADE,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- Notes with markdown content
CREATE TABLE IF NOT EXISTS notes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT NOT NULL,
    content TEXT NOT NULL DEFAULT '',
    folder_id INTEGER REFERENCES folders(id) ON DELETE SET NULL,
    author TEXT NOT NULL DEFAULT 'user',
    is_daily_note INTEGER NOT NULL DEFAULT 0,
    daily_note_date TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- Wiki links between notes (populated on save)
CREATE TABLE IF NOT EXISTS wiki_links (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    source_note_id INTEGER NOT NULL REFERENCES notes(id) ON DELETE CASCADE,
    target_note_id INTEGER REFERENCES notes(id) ON DELETE CASCADE,
    target_title TEXT NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- Indexes for common queries
CREATE INDEX IF NOT EXISTS idx_notes_folder ON notes(folder_id);
CREATE INDEX IF NOT EXISTS idx_notes_updated ON notes(updated_at DESC);
CREATE INDEX IF NOT EXISTS idx_notes_daily ON notes(is_daily_note, daily_note_date);
CREATE INDEX IF NOT EXISTS idx_wiki_links_source ON wiki_links(source_note_id);
CREATE INDEX IF NOT EXISTS idx_wiki_links_target ON wiki_links(target_note_id);
CREATE INDEX IF NOT EXISTS idx_folders_parent ON folders(parent_id);

-- Create a default "Notes" folder
INSERT OR IGNORE INTO folders (id, name) VALUES (1, 'Notes');
```

This schema supports:
- Hierarchical folders (parent_id self-reference)
- Notes with markdown content
- Author tracking (user vs clara)
- Daily notes (is_daily_note + daily_note_date)
- Wiki links between notes
- A default "Notes" folder for initial notes

FTS5 tables will be added in Phase 3 (Search).
</instruction>
<files>
- webui/migrations/001_initial_schema.sql
</files>
</task>

<task id="02.04">
<title>Integrate database into Tauri app</title>
<instruction>
Update `webui/src-tauri/src/lib.rs` to initialize the database on app start:

```rust
mod db;

use db::Database;
use tauri::Manager;

// Learn more about Tauri commands at https://tauri.app/develop/calling-rust/
#[tauri::command]
fn greet(name: &str) -> String {
    format!("Hello, {}! You've been greeted from Rust!", name)
}

#[tauri::command]
async fn get_db_path(app: tauri::AppHandle) -> Result<String, String> {
    Database::path(&app)
        .map(|p| p.display().to_string())
        .map_err(|e| e.to_string())
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_opener::init())
        .setup(|app| {
            // Initialize database
            let app_handle = app.handle().clone();
            tauri::async_runtime::block_on(async move {
                match Database::new(&app_handle).await {
                    Ok(db) => {
                        // Store database in app state for commands to access
                        app_handle.manage(db);
                        println!("Database ready");
                    }
                    Err(e) => {
                        eprintln!("Failed to initialize database: {}", e);
                        // Don't crash - the app can still run, just without database
                    }
                }
            });
            Ok(())
        })
        .invoke_handler(tauri::generate_handler![greet, get_db_path])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

This:
- Imports the db module
- Initializes database during Tauri setup
- Stores Database in Tauri's managed state
- Adds a `get_db_path` command for debugging
- Handles initialization failure gracefully (logs error, doesn't crash)
</instruction>
<files>
- webui/src-tauri/src/lib.rs
</files>
</task>

<task id="02.05">
<title>Verify database creation and schema</title>
<instruction>
Run the app to verify database initialization:

```bash
cd /Users/heidornj/Code/mypalclara/webui
npm run tauri dev
```

**Expected console output:**
```
Database path: /Users/[username]/Library/Application Support/com.mypalclara.desktop/notes.db
Database initialized successfully
Database ready
```

The path varies by platform:
- macOS: `~/Library/Application Support/com.mypalclara.desktop/notes.db`
- Windows: `C:\Users\[user]\AppData\Roaming\com.mypalclara.desktop\notes.db`
- Linux: `~/.local/share/com.mypalclara.desktop/notes.db`

Verify the database was created correctly:

```bash
# Find the database file (macOS)
ls -la ~/Library/Application\ Support/com.mypalclara.desktop/

# Verify schema
sqlite3 ~/Library/Application\ Support/com.mypalclara.desktop/notes.db ".tables"
# Expected output: folders  notes  wiki_links  _sqlx_migrations

# Check WAL mode is enabled
sqlite3 ~/Library/Application\ Support/com.mypalclara.desktop/notes.db "PRAGMA journal_mode"
# Expected output: wal

# Verify default folder exists
sqlite3 ~/Library/Application\ Support/com.mypalclara.desktop/notes.db "SELECT * FROM folders"
# Expected output: 1|Notes||[timestamp]|[timestamp]
```

Close the app after verifying.

**If database isn't created:**
1. Check console for error messages
2. Verify migrations directory exists at `webui/migrations/`
3. Ensure Cargo.toml has correct sqlx features
</instruction>
<files>
- webui/src-tauri/target/
</files>
</task>

## Verification

<verify>
- [ ] Database file exists at correct platform-specific path
- [ ] `PRAGMA journal_mode` returns `wal`
- [ ] `PRAGMA busy_timeout` returns 5000
- [ ] Tables exist: `folders`, `notes`, `wiki_links`, `_sqlx_migrations`
- [ ] Default "Notes" folder exists with id=1
- [ ] No "database is locked" errors in console
- [ ] App starts without database errors
</verify>

## Success Criteria

- SQLite database created on first launch with correct schema
- WAL mode enabled for concurrent read/write
- busy_timeout prevents "database is locked" errors
- Migration system ready for future schema changes
- Database accessible via Tauri managed state

## Output

After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md` with:
- Database file location
- Schema verification results
- Any issues encountered with migrations
- Time taken
